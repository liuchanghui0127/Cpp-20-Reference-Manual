## **9.2多线程的实现**

通过原子操作和互斥体可以实现线程的同步

### **9.2.1原子操作库**

原子类型支持原子访问，定义在<atomic>中，所有基本类型都有对应的整型原子类型，声明示例如下：
```
atomic<int> counter{0};
```
整形原子类型支持以下原子操作：fetch_add()、fetch_sub()、fetch_and()、fetch_or()、fetch_xor()、++、--、+=、-=、&=、^=和|=

### **9.1.2通过函数对象创建线程**

通过函数对象初始化线程有两种方法，一是采用统一初始化，通过构造函数创建类的实例传给线程；二是创建类的一个命名实例，将其传给线程。创建方法如下所示：
```
import <thread>;
import <iostream>;
using namespace std;
class Counter
{
public:
	Counter(int id, int numIterations)
		: m_id{ id }, m_numIterations{ numIterations }
	{
	}
	void operator()() const
	{
		for (int i{ 0 }; i < m_numIterations; ++i) {
			cout << "Counter " << m_id << " has value " << i << endl;
		}
	}
private:
	int m_id;
	int m_numIterations;
};
int main()
{
	// 使用统一初始化语法
	thread t1{ Counter{ 1, 20 } };

	// 使用命名实例
	Counter c{ 2, 12 };
	thread t2{ c };
	t1.join();
	t2.join();
}
```
### **9.1.3通过Lambda创建线程**

可以创建一个线程执行Lambda表达式，创建方法如下所示：
```
	thread t1{ [id, numIterations] {
		for (int i{ 0 }; i < numIterations; ++i) {
			cout << "Counter " << id << " has value " << i << endl;
		}
	} };
```

### **9.1.4通过成员函数创建线程**

通过成员函数创建线程可以在不同线程中执行某个对象的方法，但需要注意不同线程的争用，示例如下所示：
```
import <thread>;
import <iostream>;
using namespace std;
class Request
{
public:
	Request(int id) : m_id{ id } { }

	void process()
	{
		cout << "Processing request " << m_id << endl;
	}

private:
	int m_id;
};
int main()
{
	Request req{ 100 };
	thread t{ &Request::process, &req };
	t.join();
}
```
### **9.1.5线程本地存储**

使用thread_local关键词可以指示变量为线程本地数据，即每个线程都有自己独立的变量副本。

### **9.1.6 C++20的jthread线程**

C++20中引入了std::jthread，通过jthread创建的线程可以在析构函数中自动join，且支持协作式取消。

协作式取消指的是支持线程定期检查是否需要取消自己，通过std::stop_token和std::stop_source两个类实现。

std::stop_token用于检查取消的请求，使用stop_token调用stop_requested()检查是否需要停止。

std::stop_source用于请求线程取消执行，通过调用request_stop()方法实现。
### **9.1.7 获取线程结果**
在线程执行结束后获取线程结果有三种方法，一种是传入指向结果变量的指针或引用，将结果保存进去；二是使用std::ref()将函数对象按引用传入线程，将结果存入函数对象的类成员变量中；三是使用future。

#### **9.1.7.1 std::future和std::promise**
future在promise中存储结果，相当于promise是结果的输入端，future是结果的输出端，线程将结果放在promise中，然后通过future获取这个值。

C++提供std::future，可从中查询结果，T为计算结果的类型，通过get()方法取出结果，如果线程尚未执行完，则对get()的调用将阻塞，直到线程执行完。

注意只能在future上调用一次get()
```
future<T> myFuture{...};
T result{myfuture.get()};
```
C++提供std::promise类，可以调用set_value()存储结果，也可以调用set_exception()存储异常。

注意只能在特定promise上调用set_value()或set_exception()一次，否则抛出std::future_error异常。

通过对promise调用get_future()获取future，再通过get()方法可以访问线程运行结果。promise不能复制但可以通过move移入线程，promise使用示例如下所示：
```
import <iostream>;
import <thread>;
import <future>;

using namespace std;

void doWork(promise<int> thePromise)
{
	// 将结果存储到promise
	thePromise.set_value(42);
}

int main()
{
	// 创建promise
	promise<int> myPromise;
	// 获取promise的future
	auto theFuture{ myPromise.get_future() };
	// 创建线程并将promise传入
	thread theThread{ doWork, move(myPromise) };
	// 获取结果
	int result{ theFuture.get() };
	cout << "Result: " << result << endl;
	theThread.join();
}
```
#### **9.1.7.2 std::packaged_task**
使用packaged_task可以更方便的使用promise，其可以自动创建promise，并存储调用函数的结果和抛出的任何异常，使用示例如下所示：
```
import <iostream>;
import <thread>;
import <future>;

using namespace std;

int calculateSum(int a, int b)
{
	return a + b;
}

int main()
{
	// 创建一个packaged task运行calculateSum函数
	packaged_task<int(int, int)> task{ calculateSum };
	//获取future
	auto theFuture{ task.get_future() };
	// 创建线程执行packaged task
	thread theThread{ move(task), 39, 3 };
	// 获取结果
	int result{ theFuture.get() };
	cout << result << endl;
	theThread.join();
}
```
#### **9.1.7.3 std::async**
std::async接收一个将要执行的函数，并返回可检索结果的future，其可以通过异步和同步两种方式来运行函数
launch::async强制C++在一个不同的线程上异步执行函数
launch::deferred强制C++只有在调用get()时，才在主调线程上同步执行函数
launch::async|launch::deferred允许C++在运行时自动进行选择（默认参数）
