## 4.2指针

### 4.2.1指针的使用
可以通过指针进行显示内存分配将变量放到自由存储区，指针的声明如下所示：
```
int* pointer {nullptr};//将pointer声明为一个空指针
pointer = new int;//给pointer分配空间
*pointer = 5；//对pointer进行解索引，为新分配空间进行赋值
```
注意声明指针时需要同步进行初始化，否则可能会使程序崩溃。

同理可以通过指针指向其他变量，需要使用取址运算符&，如下所示：
```
int num {8};
int* pointer {&num};
```
该样例将pointer指针指向num变量，
### 4.2.2智能指针
智能指针可以帮助管理动态分配的内存，当智能指针离开作用域或被重置时，可以自动释放指向的内存
#### 4.2.2.1 unique_ptr
对于智能指针unique_ptr，其拥有资源唯一的所有权，可以通过std::make_unique()辅助函数创建，这是一个函数模板，需要通过<>指明需要指向的内存类型，创建方法如下：
```
auto myInt {make_unique<int>(42)}
unique_ptr<int> {new int{42}}
```
两种方法都可以进行unique_ptr创建，但更建议采用make_unique()进行创建
make_unique()默认值初始化，基本类型被初始化为0，对象进行默认构造

如果追求性能，在C++20中引入了make_unique_for_overwrite(),该函数进行默认初始化，基本类型不进行初始化即包含内存的任何内容，对象仍进行默认构造。

智能指针与标准指针一样可以使用*或->进行解引用，如下例所示：
```
#include <iostream>
using namespace std;
class Simple {
public:
    Simple() {
        cout << "Simple 构造函数被调用" << endl;
    }
    ~Simple() {
        cout << "Simple 析构函数被调用 (资源自动释放)" << endl;
    }
    void go() {
        cout << "Simple::go() 正在执行..." << endl;
    }
};

int main() {
    //初始化智能指针
    auto mySimpleSmartPtr{ make_unique<Simple>() };
    // 方式 1: 使用箭头运算符
    mySimpleSmartPtr->go();

    // 方式 2: 解引用后使用点运算符
    // 先获取对象引用，再访问成员
    (*mySimpleSmartPtr).go();
    return 0;
} // main 函数结束，mySimpleSmartPtr 超出作用域，自动调用 ~Simple()
```
使用get()和reset()方法可以获取和释放底层指针，通过get()方法可以将指针传递给需要普通指针的函数，reset（）方法可以根据需要调整指针指向。
release()方法可以断开unique_ptr与底层指针的连接，其返回底层指针，并将智能指针设置为nullptr。

由于unique_ptr具有唯一拥有权，可以通过move()函数可以显示移动unique_ptr的所有权，如下所示。
#include <iostream>;
using namespace std;
class Foo {
	public:
		Foo(unique_ptr<int> data) : m_data{ move(data) }{}
	private:
		unique_ptr<int> m_data;
};
int main(){
  auto myIntSmartPtr{ make_unique<int>(42) };
  Foo f{ move(myIntSmartPtr) };
}
#### 4.2.2.1 shared_ptr
shared_ptr为可复制的支持共享所有权的智能指针，可以通过make_shared()进行创建，make_shared同样使用值初始化，但在C++20可以使用make_shared_for_overwrite实现默认初始化。

相同地，可以使用get()和reset()进行获取和释放底层指针，需要注意的是，当最后的shared_ptr被销毁或重置时，才会释放资源。通过use_count()方法可以获取共享同一资源的shared_ptr的数量。
